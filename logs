import pandas as pd
import numpy as np
from datetime import datetime, timedelta, time
from typing import Dict, Any, List, Optional, Union, Tuple
import pytz
import logging

# Import statements from your original code
from utils.config_manager import AppConfig
from utils.logger_config import LoggerConfig
from utils.common_models import OHLCData, MarketData

# Use the logger configured in LoggerConfig
logger = LoggerConfig.get_logger("SupportResistanceCalculation")
logger.setLevel(logging.DEBUG)


class TradingStrategy:
    """
    Calculates Support and Resistance levels for a given straddle's combined premium.
    Uses the pivot point analysis method.
    """
    def __init__(self, app_configs: AppConfig, market_data: MarketData):
        self.logger = LoggerConfig.get_logger(self.__class__.__name__)
        # Set the logger level to DEBUG to show detailed steps within process_straddle_candle
        self.logger.setLevel(logging.DEBUG) 
        
        self.app_configs = app_configs
        self.market_data = market_data
        
        self.sr_levels: Dict[Union[float, str], Dict[str, Any]] = {}
        
        self.logger.info("TradingStrategy initialized (S&R focus).")

    async def _get_current_india_time(self) -> datetime:
        """Helper to get current time in India timezone."""
        india_tz = pytz.timezone('Asia/Kolkata')
        return datetime.now(india_tz)

    def _get_strike_state(self, current_strike: Union[float, str]) -> Dict[str, Any]:
        if current_strike not in self.sr_levels:
            self.sr_levels[current_strike] = {
                'prev_high': None,
                'prev_low': None,
                'primary_sequence_focus': None,
                'next_expected_secondary_level': None,
            }
        return self.sr_levels[current_strike]

    def reset_all_sr_levels(self, current_strike: Optional[Union[float, str]] = None):
        """
        Resets S&R levels and sequence tracking variables.
        If current_strike is provided, resets only for that strike.
        Otherwise, resets all tracked strikes.
        """
        if current_strike is not None:
            if current_strike in self.sr_levels:
                self.sr_levels[current_strike] = {
                    'prev_high': None,
                    'prev_low': None,
                    'primary_sequence_focus': None,
                    'next_expected_secondary_level': None,
                }
                self.logger.debug(f"S&R levels and sequence tracking for strike {current_strike} have been reset.")
            else:
                # Changed from WARNING to DEBUG or removed, as it's expected when initializing a new strike
                self.logger.debug(f"Attempted to reset non-existent strike {current_strike}. No action taken, as it was already clean.")
        else:
            self.sr_levels = {}
            self.logger.debug("All S&R levels and sequence tracking variables have been reset.")

    def set_initial_reference_candle(self, strike: Union[float, str], initial_high: float, initial_low: float):
        # Removed the call to self.reset_all_sr_levels(strike) here
        # as _get_strike_state will initialize if not present for a new TradingStrategy instance.
        current_sr_state = self._get_strike_state(strike)
        
        current_sr_state['prev_high'] = initial_high
        current_sr_state['prev_low'] = initial_low
        self.logger.debug(f"Initial reference candle set for strike {strike}: Prev_High={initial_high}, Prev_Low={initial_low}. S&R levels for this strike are currently empty.")


    def get_calculated_sr_state(self, current_strike: Union[float, str]) -> Dict[str, Any]:
        current_sr_data = self.sr_levels.get(current_strike, {})
        # Extract the S&R levels (S1, R1, etc.) and state flags
        sr_levels_only = {k: v for k, v in current_sr_data.items() if k not in ['prev_high', 'prev_low', 'primary_sequence_focus', 'next_expected_secondary_level']}
        
        return {
            'sr_levels': sr_levels_only.copy(),
            'primary_sequence_focus': current_sr_data.get('primary_sequence_focus'),
            'next_expected_secondary_level': current_sr_data.get('next_expected_secondary_level')
        }

    def _get_current_sr_flags(self, current_strike: Union[float, str]) -> Dict[str, bool]:
        current_sr_data = self._get_strike_state(current_strike)
        
        flags = {
            's1_exists': 'S1' in current_sr_data,
            'r1_exists': 'R1' in current_sr_data,
            's1_is_established': 'S1' in current_sr_data and current_sr_data['S1']['is_established'],
            'r1_is_established': 'R1' in current_sr_data and current_sr_data['R1']['is_established'],
            's1_is_tracking': 'S1' in current_sr_data and not current_sr_data['S1']['is_established'],
            'r1_is_tracking': 'R1' in current_sr_data and not current_sr_data['R1']['is_established'],
            's2_exists': 'S2' in current_sr_data,
            'r2_exists': 'R2' in current_sr_data,
            's2_is_tracking': 'S2' in current_sr_data and not current_sr_data.get('S2', {}).get('is_established', True),
            'r2_is_tracking': 'R2' in current_sr_data and not current_sr_data.get('R2', {}).get('is_established', True),
        }
        self.logger.debug(f"  [LOG] S&R Flags for {current_strike}: {flags}")
        return flags

    def _handle_initial_sr_establishment(self, current_strike: Union[float, str],
                                         current_candle_high: float, current_candle_low: float,
                                         current_candle_timestamp: datetime) -> bool:
        current_sr_state = self._get_strike_state(current_strike)

        if not current_sr_state['primary_sequence_focus']:
            if current_sr_state['prev_high'] is None or current_sr_state['prev_low'] is None:
                self.logger.debug(f"  [LOG] Initial reference candle not properly set for {current_strike}. Cannot establish S&R.")
                return False

            if current_candle_high > current_sr_state['prev_high']:
                # Price broke up (R1 breached), establish S1 with current candle's low, R1 with current candle's high
                current_sr_state['primary_sequence_focus'] = 'S1_SEQUENCE_PRIMARY'
                current_sr_state['next_expected_secondary_level'] = 'S2'
                current_sr_state['S1'] = {
                    'high': current_sr_state['prev_high'], 'low': current_candle_low, # S1 is formed from the previous high and current low
                    'breakout_type': 'INITIAL_DOWN_BREAKOUT', 'direction': 'DOWN', 'is_established': True,  
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] Initial S1 established due to UP breakout for {current_strike}. S1 range H:{current_sr_state['S1']['high']:.2f}/L:{current_sr_state['S1']['low']:.2f}. Primary focus: S1_SEQUENCE_PRIMARY.")
                
                # R1 implicitly set by the high of the breakout candle and previous low
                current_sr_state['R1'] = {
                    'high': current_candle_high, 'low': current_sr_state['prev_low'],
                    'breakout_type': 'INITIAL_UP_BREAKOUT', 'direction': 'UP', 'is_established': False, # R1 is tracking its new range
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] Implicit R1 established for {current_strike} (tracking). R1 range H:{current_sr_state['R1']['high']:.2f}/L:{current_sr_state['R1']['low']:.2f}.")
                return True
                
            elif current_candle_low < current_sr_state['prev_low']:
                # Price broke down (S1 breached), establish R1 with current candle's high, S1 with current candle's low
                current_sr_state['primary_sequence_focus'] = 'R1_SEQUENCE_PRIMARY'
                current_sr_state['next_expected_secondary_level'] = 'R2'
                current_sr_state['R1'] = {
                    'high': current_candle_high, 'low': current_sr_state['prev_low'], # R1 is formed from the current high and previous low
                    'breakout_type': 'INITIAL_UP_BREAKOUT', 'direction': 'UP', 'is_established': True,  
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] Initial R1 established due to DOWN breakout for {current_strike}. R1 range H:{current_sr_state['R1']['high']:.2f}/L:{current_sr_state['R1']['low']:.2f}. Primary focus: R1_SEQUENCE_PRIMARY.")
                
                # S1 implicitly set by the low of the breakout candle and previous high
                current_sr_state['S1'] = {
                    'high': current_sr_state['prev_high'], 'low': current_candle_low,
                    'breakout_type': 'INITIAL_DOWN_BREAKOUT', 'direction': 'DOWN', 'is_established': False, # S1 is tracking its new range
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] Implicit S1 established for {current_strike} (tracking). S1 range H:{current_sr_state['S1']['high']:.2f}/L:{current_sr_state['S1']['low']:.2f}.")
                return True
                
            else:
                self.logger.debug(f"  [HIST] No initial breakout for {current_strike}. Current candle becomes new reference for next comparison.")
                return False
        return False

    def _handle_direct_primary_breach(self, current_strike: Union[float, str],
                                      current_candle_high: float, current_candle_low: float,
                                      current_candle_timestamp: datetime) -> bool:
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)

        if flags['r1_is_established'] and current_candle_high > current_sr_state['R1']['high']:
            self.logger.debug(f"  [HIST] Established R1 ({current_sr_state['R1']['high']:.2f}) BREACHED UP by current candle high ({current_candle_high:.2f}) for {current_strike}. R1 now TRACKING.")
            current_sr_state['R1'] = {
                'high': current_candle_high, 'low': current_candle_low,
                'breakout_type': 'R1_BREACH_DIRECT', 'direction': 'UP', 'is_established': False,
                'timestamp': current_candle_timestamp
            }
            if 'R2' in current_sr_state: del current_sr_state['R2']
            if 'S2' in current_sr_state: del current_sr_state['S2']
            
            current_sr_state['primary_sequence_focus'] = 'S1_SEQUENCE_PRIMARY'  
            current_sr_state['next_expected_secondary_level'] = 'S2'  
            self.logger.debug(f"  [HIST] Primary sequence for {current_strike} shifted to S1_SEQUENCE_PRIMARY. Next secondary: S2. Skipping further S&R rules for this candle.")
            return True

        elif flags['s1_is_established'] and current_candle_low < current_sr_state['S1']['low']:
            self.logger.debug(f"  [HIST] Established S1 ({current_sr_state['S1']['low']:.2f}) BREACHED DOWN by current candle low ({current_candle_low:.2f}) for {current_strike}. S1 now TRACKING, S2 resets.")
            current_sr_state['S1'] = {
                'high': current_candle_high, 'low': current_candle_low,
                'breakout_type': 'S1_BREACH_DIRECT', 'direction': 'DOWN', 'is_established': False,
                'timestamp': current_candle_timestamp
            }
            if 'R2' in current_sr_state: del current_sr_state['R2']
            if 'S2' in current_sr_state: del current_sr_state['S2']
            
            current_sr_state['primary_sequence_focus'] = 'R1_SEQUENCE_PRIMARY'  
            current_sr_state['next_expected_secondary_level'] = 'R2'  
            self.logger.debug(f"  [HIST] Primary sequence for {current_strike} shifted to R1_SEQUENCE_PRIMARY. Next secondary: R2. Skipping further S&R rules for this candle.")
            return True
        return False

    def _update_tracking_ranges(self, current_strike: Union[float, str],
                                current_candle_high: float, current_candle_low: float):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Checking for tracking range updates for {current_strike}.")
        
        if flags['s1_is_tracking']:
            if current_candle_high > current_sr_state['S1']['high']: 
                current_sr_state['S1']['high'] = current_candle_high
                self.logger.debug(f"  [LOG] S1 high updated to {current_candle_high:.2f} while tracking.")
            if current_candle_low < current_sr_state['S1']['low']: 
                current_sr_state['S1']['low'] = current_candle_low
                self.logger.debug(f"  [LOG] S1 low updated to {current_candle_low:.2f} while tracking.")
            self.logger.debug(f"  [LOG] S1 tracking for {current_strike}: current range H:{current_sr_state['S1']['high']:.2f}, L:{current_sr_state['S1']['low']:.2f}")

        if flags['r1_is_tracking']:
            if current_candle_high > current_sr_state['R1']['high']: 
                current_sr_state['R1']['high'] = current_candle_high
                self.logger.debug(f"  [LOG] R1 high updated to {current_candle_high:.2f} while tracking.")
            if current_candle_low < current_sr_state['R1']['low']: 
                current_sr_state['R1']['low'] = current_candle_low
                self.logger.debug(f"  [LOG] R1 low updated to {current_candle_low:.2f} while tracking.")
            self.logger.debug(f"  [LOG] R1 tracking for {current_strike}: current range H:{current_sr_state['R1']['high']:.2f}, L:{current_sr_state['R1']['low']:.2f}")

        if flags['s2_is_tracking']:
            if current_candle_high > current_sr_state['S2']['high']: 
                current_sr_state['S2']['high'] = current_candle_high
                self.logger.debug(f"  [LOG] S2 high updated to {current_candle_high:.2f} while tracking.")
            if current_candle_low < current_sr_state['S2']['low']: 
                current_sr_state['S2']['low'] = current_candle_low
                self.logger.debug(f"  [LOG] S2 low updated to {current_candle_low:.2f} while tracking.")
            self.logger.debug(f"  [LOG] S2 tracking for {current_strike}: current range H:{current_sr_state['S2']['high']:.2f}, L:{current_sr_state['S2']['low']:.2f}")

        if flags['r2_is_tracking']:
            if current_candle_high > current_sr_state['R2']['high']: 
                current_sr_state['R2']['high'] = current_candle_high
                self.logger.debug(f"  [LOG] R2 high updated to {current_candle_high:.2f} while tracking.")
            if current_candle_low < current_sr_state['R2']['low']: 
                current_sr_state['R2']['low'] = current_candle_low
                self.logger.debug(f"  [LOG] R2 low updated to {current_candle_low:.2f} while tracking.")
            self.logger.debug(f"  [LOG] R2 tracking for {current_strike}: current range H:{current_sr_state['R2']['high']:.2f}, L:{current_sr_state['R2']['low']:.2f}")

    def _handle_primary_breach_active_secondary(self, current_strike: Union[float, str],
                                                current_candle_high: float, current_candle_low: float,
                                                current_candle_timestamp: datetime):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Entering _handle_primary_breach_active_secondary for {current_strike}. Current R1 is_established: {flags['r1_is_established']}, R2 exists: {flags['r2_exists']}, R2 is tracking: {flags['r2_is_tracking']}")
        self.logger.debug(f"  [LOG] Current S1 is_established: {flags['s1_is_established']}, S2 exists: {flags['s2_exists']}, S2 is tracking: {flags['s2_is_tracking']}")


        if flags['s1_is_established'] and flags['s2_is_tracking'] and current_candle_low < current_sr_state['S1']['low']:
            self.logger.debug(f"  [HIST] S1 BREACHED DOWN ({current_sr_state['S1']['low']:.2f} -> {current_candle_low:.2f}) while S2 was tracking for {current_strike}. S1 now TRACKING, S2 resets.")
            current_sr_state['S1'] = {
                'high': current_candle_high, 'low': current_candle_low,
                'breakout_type': 'S1_BREACH_S2_ACTIVE', 'direction': 'DOWN', 'is_established': False,
                'timestamp': current_candle_timestamp
            }
            if 'S2' in current_sr_state: del current_sr_state['S2']
            if 'R2' in current_sr_state: del current_sr_state['R2']
            
            current_sr_state['primary_sequence_focus'] = 'R1_SEQUENCE_PRIMARY'
            current_sr_state['next_expected_secondary_level'] = 'R2'
            self.logger.debug(f"  [HIST] Primary sequence for {current_strike} shifted to R1_SEQUENCE_PRIMARY. Next secondary: R2.")

        elif flags['r1_is_established'] and flags['r2_is_tracking'] and current_candle_high > current_sr_state['R1']['high']:
            self.logger.debug(f"  [HIST] R1 BREACHED UP ({current_sr_state['R1']['high']:.2f} -> {current_candle_high:.2f}) while R2 was tracking for {current_strike}. R1 now TRACKING, R2 resets.")
            current_sr_state['R1'] = {
                'high': current_candle_high, 'low': current_candle_low,
                'breakout_type': 'R1_BREACH_R2_ACTIVE', 'direction': 'UP', 'is_established': False,
                'timestamp': current_candle_timestamp
            }
            if 'R2' in current_sr_state: del current_sr_state['R2']
            if 'S2' in current_sr_state: del current_sr_state['S2']
            
            current_sr_state['primary_sequence_focus'] = 'S1_SEQUENCE_PRIMARY'
            current_sr_state['next_expected_secondary_level'] = 'S2'
            self.logger.debug(f"  [HIST] Primary sequence for {current_strike} shifted to S1_SEQUENCE_PRIMARY. Next secondary: S2.")

    def _check_and_establish_primary(self, current_strike: Union[float, str],
                                     current_candle_high: float, current_candle_low: float,
                                     current_candle_timestamp: datetime):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Entering _check_and_establish_primary for {current_strike}. S1 is_tracking: {flags['s1_is_tracking']}, R1 is_tracking: {flags['r1_is_tracking']}")

        if flags['s1_is_tracking'] and current_candle_low > current_sr_state['S1']['low']:
            current_sr_state['S1']['is_established'] = True
            current_sr_state['S1']['breakout_type'] = 'RETRACKED_UP'
            current_sr_state['S1']['timestamp'] = current_candle_timestamp
            self.logger.debug(f"  [HIST] S1 re-tracked UP for strike {current_strike}: Established at L:{current_sr_state['S1']['low']:.2f}. Is Established: True (Current Low: {current_candle_low:.2f}).")
            self.logger.debug(f"  [LOG] S1 (Support) has been established at range H:{current_sr_state['S1']['high']:.2f}, L:{current_sr_state['S1']['low']:.2f}.")

            if current_sr_state['primary_sequence_focus'] == 'S1_SEQUENCE_PRIMARY' and 'R1' not in current_sr_state:
                current_sr_state['R1'] = {
                    'high': current_candle_high, 'low': current_candle_low,
                    'breakout_type': 'INITIATED_AFTER_S1_ESTABLISHED', 'direction': 'UP', 'is_established': False,
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] R1 tracking initiated as S1 established (S1_SEQUENCE_PRIMARY) for {current_strike}. R1 high={current_sr_state['R1']['high']:.2f}, low={current_sr_state['R1']['low']:.2f}.")


        if flags['r1_is_tracking'] and current_candle_high < current_sr_state['R1']['high']:
            current_sr_state['R1']['is_established'] = True
            current_sr_state['R1']['breakout_type'] = 'RETRACKED_DOWN'
            current_sr_state['R1']['timestamp'] = current_candle_timestamp
            self.logger.debug(f"  [HIST] R1 re-tracked DOWN for strike {current_strike}: Established at H:{current_sr_state['R1']['high']:.2f}. Is Established: True (Current High: {current_candle_high:.2f}).")
            self.logger.debug(f"  [LOG] R1 (Resistance) has been established at range H:{current_sr_state['R1']['high']:.2f}, L:{current_sr_state['R1']['low']:.2f}.")

            if current_sr_state['primary_sequence_focus'] == 'R1_SEQUENCE_PRIMARY' and 'S1' not in current_sr_state:
                current_sr_state['S1'] = {
                    'high': current_candle_high, 'low': current_candle_low,
                    'breakout_type': 'INITIATED_AFTER_R1_ESTABLISHED', 'direction': 'DOWN', 'is_established': False,
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] S1 tracking initiated as R1 established (R1_SEQUENCE_PRIMARY) for {current_strike}. S1 high={current_sr_state['S1']['high']:.2f}, low={current_sr_state['S1']['low']:.2f}.")

    def _initiate_secondary_levels(self, current_strike: Union[float, str],
                                    current_candle_high: float, current_candle_low: float,
                                    current_candle_timestamp: datetime):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Entering _initiate_secondary_levels for {current_strike}. R1 established: {flags['r1_is_established']}, S1 established: {flags['s1_is_established']}, S2 exists: {flags['s2_exists']}, R2 exists: {flags['r2_exists']}")

        if flags['s1_is_established'] and flags['r1_is_established'] and not flags['s2_exists'] and not flags['r2_exists']:
            if not current_sr_state['primary_sequence_focus']:
                if current_sr_state['next_expected_secondary_level'] is None:
                    self.logger.warning(f"  [WARN] Both S1 and R1 established for {current_strike}, but primary_sequence_focus and next_expected_secondary_level are missing. This indicates an unexpected state. Defaulting to S1_SEQUENCE_PRIMARY.")
                    current_sr_state['primary_sequence_focus'] = 'S1_SEQUENCE_PRIMARY'
                    current_sr_state['next_expected_secondary_level'] = 'S2'


            if current_sr_state['next_expected_secondary_level'] == 'R2':
                current_sr_state['R2'] = {
                    'high': current_candle_high, 'low': current_candle_low,
                    'breakout_type': 'INITIATED_AFTER_R1_S1_ESTABLISHED', 'direction': 'UP', 'is_established': False,
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] R2 tracking initiated as R1 and S1 established for {current_strike}. R2 high={current_sr_state['R2']['high']:.2f}, low={current_sr_state['R2']['low']:.2f}.")
                self.logger.debug(f"  [LOG] R2 (Secondary Resistance) tracking has started with range H:{current_sr_state['R2']['high']:.2f}, L:{current_sr_state['R2']['low']:.2f}.")
                current_sr_state['next_expected_secondary_level'] = 'S2' # Toggle for next secondary
            elif current_sr_state['next_expected_secondary_level'] == 'S2':
                current_sr_state['S2'] = {
                    'high': current_candle_high, 'low': current_candle_low,
                    'breakout_type': 'INITIATED_FROM_S1_BREAKDOWN', 'direction': 'DOWN', 'is_established': False,
                    'timestamp': current_candle_timestamp
                }
                self.logger.debug(f"  [HIST] S2 tracking initiated as R1 and S1 established for {current_strike}. S2 high={current_sr_state['S2']['high']:.2f}, low={current_sr_state['S2']['low']:.2f}.")
                self.logger.debug(f"  [LOG] S2 (Secondary Support) tracking has started with range H:{current_sr_state['S2']['high']:.2f}, L:{current_sr_state['S2']['low']:.2f}.")
                current_sr_state['next_expected_secondary_level'] = 'R2' # Toggle for next secondary

    def _handle_primary_advancement_by_secondary(self, current_strike: Union[float, str],
                                                 current_candle_timestamp: datetime):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Entering _handle_primary_advancement_by_secondary for {current_strike}.")

        if flags['r1_is_established'] and flags['r2_exists'] and flags['r2_is_tracking']:
            if current_sr_state['R2']['high'] > current_sr_state['R1']['high']: # R2 extends beyond R1
                self.logger.debug(f"  [HIST] R1 advanced by R2 breakout ({current_sr_state['R1']['high']:.2f} -> {current_sr_state['R2']['high']:.2f}) for {current_strike}. R1 now TRACKING from new range, R2 resets.")
                self.logger.debug(f"  [LOG] R1 (Resistance) has been advanced and is now tracking the new R2 range.")
                current_sr_state['R1'] = {
                    'high': current_sr_state['R2']['high'],  
                    'low': current_sr_state['R2']['low'],
                    'breakout_type': 'R1_ADVANCED_BY_SECONDARY_BREAKOUT',  
                    'direction': 'UP',  
                    'is_established': False,
                    'timestamp': current_candle_timestamp  
                }
                del current_sr_state['R2']
                if 'S2' in current_sr_state:
                    del current_sr_state['S2'] # Secondary levels should be relative to primaries
                current_sr_state['next_expected_secondary_level'] = 'S2' # After R1 advances, expect S2 next

        if flags['s1_is_established'] and flags['s2_exists'] and flags['s2_is_tracking']:
            if current_sr_state['S2']['low'] < current_sr_state['S1']['low']: # S2 extends beyond S1
                self.logger.debug(f"  [HIST] S1 advanced by S2 breakout ({current_sr_state['S1']['low']:.2f} -> {current_sr_state['S2']['low']:.2f}) for {current_strike}. S1 now TRACKING from new range, S2 resets.")
                self.logger.debug(f"  [LOG] S1 (Support) has been advanced and is now tracking the new S2 range.")
                current_sr_state['S1'] = {
                    'high': current_sr_state['S2']['high'],  
                    'low': current_sr_state['S2']['low'],
                    'breakout_type': 'S1_ADVANCED_BY_SECONDARY_BREAKOUT',  
                    'direction': 'DOWN',  
                    'is_established': False,
                    'timestamp': current_candle_timestamp  
                }
                del current_sr_state['S2']
                if 'R2' in current_sr_state:
                    del current_sr_state['R2'] # Secondary levels should be relative to primaries
                current_sr_state['next_expected_secondary_level'] = 'R2' # After S1 advances, expect R2 next

    def _handle_secondary_consolidation(self, current_strike: Union[float, str],
                                        current_candle_high: float, current_candle_low: float,
                                        current_candle_timestamp: datetime):
        current_sr_state = self._get_strike_state(current_strike)
        flags = self._get_current_sr_flags(current_strike)
        
        self.logger.debug(f"  [LOG] Entering _handle_secondary_consolidation for {current_strike}.")

        if flags['r2_is_tracking'] and current_candle_high < current_sr_state['R2']['high'] and current_candle_low > current_sr_state['R2']['low']:
            # Consolidation within R2 range
            current_sr_state['R2']['is_established'] = True
            current_sr_state['R2']['breakout_type'] = 'RETRACKED_DOWN_CONSOLIDATION'
            current_sr_state['R2']['timestamp'] = current_candle_timestamp
            self.logger.debug(f"  [HIST] R2 re-tracked DOWN for strike {current_strike}: Range H:{current_sr_state['R2']['high']:.2f}/L:{current_sr_state['R2']['low']:.2f}. Is Established: True. R1 takes R2's value.")
            self.logger.debug(f"  [LOG] R2 (Secondary Resistance) consolidated. R1 is now taking on its value: H:{current_sr_state['R2']['high']:.2f}, L:{current_sr_state['R2']['low']:.2f}.")
            
            # When secondary consolidates, primary takes its value and is established
            current_sr_state['R1'] = {
                'high': current_sr_state['R2']['high'],  
                'low': current_sr_state['R2']['low'],
                'breakout_type': 'CONSOLIDATED_FROM_R2',  
                'direction': 'UP',
                'is_established': True,
                'timestamp': current_candle_timestamp
            }
            del current_sr_state['R2'] # R2 is consumed
            current_sr_state['next_expected_secondary_level'] = 'S2' # Next expectation after R1 is new S2

        if flags['s2_is_tracking'] and current_candle_low > current_sr_state['S2']['low'] and current_candle_high < current_sr_state['S2']['high']:
            # Consolidation within S2 range
            current_sr_state['S2']['is_established'] = True
            current_sr_state['S2']['breakout_type'] = 'RETRACKED_UP_CONSOLIDATION'
            current_sr_state['S2']['timestamp'] = current_candle_timestamp
            self.logger.debug(f"  [HIST] S2 re-tracked UP for strike {current_strike}: Range H:{current_sr_state['S2']['high']:.2f}/L:{current_sr_state['S2']['low']:.2f}. Is Established: True. S1 takes S2's value.")
            self.logger.debug(f"  [LOG] S2 (Secondary Support) consolidated. S1 is now taking on its value: H:{current_sr_state['S2']['high']:.2f}, L:{current_sr_state['S2']['low']:.2f}.")

            # When secondary consolidates, primary takes its value and is established
            current_sr_state['S1'] = {
                'high': current_sr_state['S2']['high'],  
                'low': current_sr_state['S2']['low'],
                'breakout_type': 'CONSOLIDATED_FROM_S2',  
                'direction': 'DOWN',
                'is_established': True,
                'timestamp': current_candle_timestamp
            }
            del current_sr_state['S2'] # S2 is consumed
            current_sr_state['next_expected_secondary_level'] = 'R2' # Next expectation after S1 is new R2

    def process_straddle_candle(self, current_strike: Union[float, str], candle_data: pd.Series):
        # Ensure the state for current_strike exists and is initialized
        current_sr_state = self._get_strike_state(current_strike)

        current_candle_high = float(candle_data['high'])
        current_candle_low = float(candle_data['low'])
        current_candle_open = float(candle_data['open'])
        current_candle_close = float(candle_data['close'])
        current_candle_timestamp = candle_data.name

        self.logger.debug(f"--- Processing Candle ({current_candle_timestamp.strftime('%H:%M:%S')}) for S&R for strike {current_strike} ---")
        self.logger.debug(f"  Candle OHLC: O:{current_candle_open:.2f}, H:{current_candle_high:.2f}, L:{current_candle_low:.2f}, C:{current_candle_close:.2f}")
        
        # --- FIX: Handle potential None values for previous candle high/low to avoid ValueError ---
        prev_high_str = f"{current_sr_state['prev_high']:.2f}" if current_sr_state['prev_high'] is not None else 'N/A'
        prev_low_str = f"{current_sr_state['prev_low']:.2f}" if current_sr_state['prev_low'] is not None else 'N/A'
        self.logger.debug(f"  Previous Candle Ref: High={prev_high_str}, Low={prev_low_str}")

        self.logger.debug(f"  Initial S&R State for {current_strike}: {self.get_calculated_sr_state(current_strike)}")


        # self.logger.debug(f"  [STEP] Calling _handle_initial_sr_establishment...")
        if self._handle_initial_sr_establishment(current_strike, current_candle_high,
                                                current_candle_low, current_candle_timestamp):
            current_sr_state['prev_high'] = current_candle_high
            current_sr_state['prev_low'] = current_candle_low
            # self.logger.debug(f"  [RESULT] Initial S&R established or updated. EARLY RETURN.")
            # self.logger.debug(f"    FINAL S&R State for {current_strike}: {self.get_calculated_sr_state(current_strike)}")
            
            # --- FIX: Handle potential None values for previous candle high/low to avoid ValueError ---
            final_prev_high_str = f"{current_sr_state['prev_high']:.2f}" if current_sr_state['prev_high'] is not None else 'N/A'
            final_prev_low_str = f"{current_sr_state['prev_low']:.2f}" if current_sr_state['prev_low'] is not None else 'N/A'
            # self.logger.debug(f"    FINAL prev_high for {current_strike}: {final_prev_high_str}, prev_low for {current_strike}: {final_prev_low_str}")
            return

        if not current_sr_state['primary_sequence_focus']:
            current_sr_state['prev_high'] = current_candle_high
            current_sr_state['prev_low'] = current_candle_low
            self.logger.debug(f"  [RESULT] No primary sequence focus established yet for {current_strike}. EARLY RETURN.")
            self.logger.debug(f"    FINAL S&R State for {current_strike}: {self.get_calculated_sr_state(current_strike)}")
            
            # --- FIX: Handle potential None values for previous candle high/low to avoid ValueError ---
            final_prev_high_str = f"{current_sr_state['prev_high']:.2f}" if current_sr_state['prev_high'] is not None else 'N/A'
            final_prev_low_str = f"{current_sr_state['prev_low']:.2f}" if current_sr_state['prev_low'] is not None else 'N/A'
            self.logger.debug(f"    FINAL prev_high for {current_strike}: {final_prev_high_str}, prev_low for {current_strike}: {final_prev_low_str}")
            return

        # self.logger.debug(f"  [STEP] Calling _handle_direct_primary_breach...")
        if self._handle_direct_primary_breach(current_strike, current_candle_high,
                                              current_candle_low, current_candle_timestamp):
            current_sr_state['prev_high'] = current_candle_high
            current_sr_state['prev_low'] = current_candle_low
            # self.logger.debug(f"  [RESULT] Direct primary breach handled. EARLY RETURN.")
            # self.logger.debug(f"    FINAL S&R State for {current_strike}: {self.get_calculated_sr_state(current_strike)}")
            
            # --- FIX: Handle potential None values for previous candle high/low to avoid ValueError ---
            final_prev_high_str = f"{current_sr_state['prev_high']:.2f}" if current_sr_state['prev_high'] is not None else 'N/A'
            final_prev_low_str = f"{current_sr_state['prev_low']:.2f}" if current_sr_state['prev_low'] is not None else 'N/A'
            self.logger.debug(f"    FINAL prev_high for {current_strike}: {final_prev_high_str}, prev_low for {current_strike}: {final_prev_low_str}")
            return

        self.logger.debug(f"  [STEP] Calling _update_tracking_ranges...")
        self._update_tracking_ranges(current_strike, current_candle_high, current_candle_low)
        self.logger.debug(f"  [RESULT] Tracking ranges updated. Current S&R State: {self.get_calculated_sr_state(current_strike)}")


        self.logger.debug(f"  [STEP] Calling _handle_primary_breach_active_secondary...")
        self._handle_primary_breach_active_secondary(current_strike, current_candle_high,
                                                     current_candle_low, current_candle_timestamp)
        self.logger.debug(f"  [RESULT] Primary breach with active secondary handled. Current S&R State: {self.get_calculated_sr_state(current_strike)}")

        self.logger.debug(f"  [STEP] Calling _check_and_establish_primary...")
        self._check_and_establish_primary(current_strike, current_candle_high,
                                          current_candle_low, current_candle_timestamp)
        self.logger.debug(f"  [RESULT] Primary levels checked/established. Current S&R State: {self.get_calculated_sr_state(current_strike)}")

        self.logger.debug(f"  [STEP] Calling _initiate_secondary_levels...")
        self._initiate_secondary_levels(current_strike, current_candle_high,
                                        current_candle_low, current_candle_timestamp)
        self.logger.debug(f"  [RESULT] Secondary levels initiated. Current S&R State: {self.get_calculated_sr_state(current_strike)}")

        self.logger.debug(f"  [STEP] Calling _handle_primary_advancement_by_secondary...")
        self._handle_primary_advancement_by_secondary(current_strike, current_candle_timestamp)
        self.logger.debug(f"  [RESULT] Primary advancement by secondary handled. Current S&R State: {self.get_calculated_sr_state(current_strike)}")

        self.logger.debug(f"  [STEP] Calling _handle_secondary_consolidation...")
        self._handle_secondary_consolidation(current_strike, current_candle_high,
                                             current_candle_low, current_candle_timestamp)
        self.logger.debug(f"  [RESULT] Secondary consolidation handled. Current S&R State: {self.get_calculated_sr_state(current_strike)}")

        current_sr_state['prev_high'] = current_candle_high
        current_sr_state['prev_low'] = current_candle_low

        self.logger.debug(f"--- End of Candle ({current_candle_timestamp.strftime('%H:%M:%S')}) S&R for strike {current_strike} ---")
        # self.logger.debug(f"    FINAL S&R State for {current_strike}: {self.get_calculated_sr_state(current_strike)}")
        self.logger.debug(f"    FINAL primary_sequence_focus for {current_strike}: {current_sr_state['primary_sequence_focus']}")
        
        # --- FIX: Handle potential None values for previous candle high/low to avoid ValueError ---
        final_prev_high_str = f"{current_sr_state['prev_high']:.2f}" if current_sr_state['prev_high'] is not None else 'N/A'
        final_prev_low_str = f"{current_sr_state['prev_low']:.2f}" if current_sr_state['prev_low'] is not None else 'N/A'
        self.logger.debug(f"    FINAL prev_high for {current_strike}: {final_prev_high_str}, prev_low for {current_strike}: {final_prev_low_str}")


def calculate_support_resistance(
    app_configs: AppConfig,
    combined_straddle_historical_data: Dict[Union[float, str], Dict[str, Any]],
    market_data: MarketData
) -> Dict[str, Dict[str, Any]]:
    
    total_candles_for_sr_log = 0
    for strike_key, straddles_at_strike in combined_straddle_historical_data.items():
        # logger.debug(f"DEBUG: Processing strike_key: {strike_key}, Type of straddles_at_strike: {type(straddles_at_strike)}, Value: {straddles_at_strike}")
        if not isinstance(straddles_at_strike, dict):
            logger.error(f"Expected dictionary for straddles_at_strike for strike_key {strike_key}, but got type {type(straddles_at_strike)}. Value: {straddles_at_strike}. Skipping this strike.")
            continue
        for straddle_id, straddle_details in straddles_at_strike.items():
            if 'combined_ohlc_data' in straddle_details and not straddle_details['combined_ohlc_data'].empty:
                total_candles_for_sr_log += len(straddle_details['combined_ohlc_data'])

    logger.info(f"Starting S&R calculation for {total_candles_for_sr_log} candles across straddles.")
    
    augmented_straddles_with_sr: Dict[str, Dict[str, Any]] = {}
    
    if not combined_straddle_historical_data:
        logger.warning("No combined straddle historical data provided for S&R calculation. Returning empty result.")
        return augmented_straddles_with_sr

    for strike_key, straddles_at_strike in combined_straddle_historical_data.items():
        # logger.debug(f"DEBUG: Processing strike_key: {strike_key}, Type of straddles_at_strike: {type(straddles_at_strike)}, Value: {straddles_at_strike}")
        if not isinstance(straddles_at_strike, dict):
            logger.error(f"Expected dictionary for straddles_at_strike for strike_key {strike_key}, but got type {type(straddles_at_strike)}. Value: {straddles_at_strike}. Skipping this strike.")
            continue
        for straddle_id, straddle_details in straddles_at_strike.items():
            logger.debug(f"Processing S&R for straddle: {straddle_id}")
            
            straddle_df_candles = straddle_details.get('combined_ohlc_data')
            
            if straddle_df_candles is None or straddle_df_candles.empty:
                logger.warning(f"Insufficient or no combined_ohlc_data DataFrame for straddle {straddle_id}. Skipping S&R calculation.")
                continue

            if len(straddle_df_candles) < app_configs.sr_candle_limit:
                logger.warning(f"Not enough candles for straddle {straddle_id} (needed {app_configs.sr_candle_limit} candles, got {len(straddle_df_candles)}). Skipping S&R calculation.")
                continue
            elif len(straddle_df_candles) > app_configs.sr_candle_limit:
                straddle_df_candles = straddle_df_candles.tail(app_configs.sr_candle_limit)
                logger.debug(f"Sliced straddle {straddle_id} OHLC data to last {app_configs.sr_candle_limit} candles for S&R calculation.")

            if not isinstance(straddle_df_candles.index, pd.DatetimeIndex):
                try:
                    straddle_df_candles.index = pd.to_datetime(straddle_df_candles.index)
                    logger.debug(f"Converted DataFrame index to DatetimeIndex for straddle {straddle_id}.")
                except Exception as e:
                    logger.error(f"Failed to convert DataFrame index to datetime for straddle {straddle_id}: {e}. Skipping S&R calculation.", exc_info=True)
                    continue
                
            sr_calculator = TradingStrategy(app_configs, market_data)

            if 'high' not in straddle_df_candles.columns or 'low' not in straddle_df_candles.columns:
                logger.error(f"Missing 'high' or 'low' columns in combined_ohlc_data for {straddle_id}. Cannot calculate S&R. Skipping.", exc_info=True)
                continue

            # Ensure there's at least one candle to set the initial reference
            if straddle_df_candles.empty:
                logger.warning(f"No candles found after slicing for straddle {straddle_id}. Skipping initial reference setting.")
                continue

            initial_reference_candle = straddle_df_candles.iloc[0]
            sr_calculator.set_initial_reference_candle(
                strike_key, # This strike_key serves as the unique ID for the straddle in sr_calculator's context
                initial_reference_candle['high'],
                initial_reference_candle['low']
            )
            
            # Start processing from the second candle as the first is the reference
            for index, candle_data in straddle_df_candles.iloc[1:].iterrows():
                sr_calculator.process_straddle_candle(strike_key, candle_data)

            final_sr_state = sr_calculator.get_calculated_sr_state(strike_key)
            
            augmented_details = straddle_details.copy()
            
            augmented_details['support_resistance_data'] = final_sr_state
            
            augmented_details['best_straddle_candidate'] = False # Default to False as per request

            # Ensure the straddle_id is used as the key for augmented_straddles_with_sr
            augmented_straddles_with_sr[straddle_id] = augmented_details

    logger.info(f"Completed S&R calculation for {len(augmented_straddles_with_sr)} straddles.")

    return augmented_straddles_with_sr
